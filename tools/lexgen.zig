const std = @import("std");

const TokenDef = struct {
    name: []const u8,
    regex: []const u8,
};

fn setRange(row: *[256]u16, first: u8, last: u8, to: u16) void {
    var c: u16 = first;
    while (c <= last) : (c += 1) {
        row[c] = to;
    }
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const alloc = gpa.allocator();

    // load token spec
    const data = try std.fs.cwd().readFileAlloc(alloc, "tools/tokens.json", 1024 * 1024);
    defer alloc.free(data);
    const parsed = try std.json.parseFromSlice([]TokenDef, alloc, data, .{});
    defer parsed.deinit();

    var out_file = try std.fs.cwd().createFile("src/include/dfa_table.h", .{ .truncate = true });
    defer out_file.close();

    const INVALID_STATE: u16 = 0xffff;
    const START_STATE: u16 = 0;
    const NUM_STATES = 20;

    var states: [NUM_STATES][256]u16 = undefined;
    for (0..NUM_STATES) |i| {
        for (0..256) |j| {
            states[i][j] = INVALID_STATE;
        }
    }

    var accepts: [NUM_STATES]i16 = .{-1} ** NUM_STATES;

    const S_START: u16 = 0;
    const S_IDENT: u16 = 1;
    const S_INT: u16 = 2;
    const S_PLUS: u16 = 3;
    const S_MINUS: u16 = 4;
    const S_STAR: u16 = 5;
    const S_SLASH: u16 = 6;
    const S_EQ: u16 = 7;
    const S_EQEQ: u16 = 8;
    const S_BANG: u16 = 9;
    const S_NEQ: u16 = 10;
    const S_LPAREN: u16 = 11;
    const S_RPAREN: u16 = 12;
    const S_LBRACE: u16 = 13;
    const S_RBRACE: u16 = 14;
    const S_SEMI: u16 = 15;
    const S_COMMA: u16 = 16;
    const S_STRING: u16 = 17;
    const S_ESCAPE: u16 = 18;
    const S_STRING_END: u16 = 19;

    // start transitions
    setRange(&states[S_START], 'a', 'z', S_IDENT);
    setRange(&states[S_START], 'A', 'Z', S_IDENT);
    states[S_START]['_'] = S_IDENT;
    setRange(&states[S_START], '0', '9', S_INT);
    states[S_START]['+'] = S_PLUS;
    states[S_START]['-'] = S_MINUS;
    states[S_START]['*'] = S_STAR;
    states[S_START]['/'] = S_SLASH;
    states[S_START]['='] = S_EQ;
    states[S_START]['!'] = S_BANG;
    states[S_START]['('] = S_LPAREN;
    states[S_START][')'] = S_RPAREN;
    states[S_START]['{'] = S_LBRACE;
    states[S_START]['}'] = S_RBRACE;
    states[S_START][';'] = S_SEMI;
    states[S_START][','] = S_COMMA;
    states[S_START]['"'] = S_STRING;

    // identifier
    setRange(&states[S_IDENT], 'a', 'z', S_IDENT);
    setRange(&states[S_IDENT], 'A', 'Z', S_IDENT);
    setRange(&states[S_IDENT], '0', '9', S_IDENT);
    states[S_IDENT]['_'] = S_IDENT;
    accepts[S_IDENT] = tokenId("identifier");

    // integer
    setRange(&states[S_INT], '0', '9', S_INT);
    accepts[S_INT] = tokenId("int_literal");

    accepts[S_PLUS] = tokenId("plus");
    accepts[S_MINUS] = tokenId("minus");
    accepts[S_STAR] = tokenId("star");
    accepts[S_SLASH] = tokenId("slash");

    states[S_EQ]['='] = S_EQEQ;
    accepts[S_EQ] = tokenId("equal");
    accepts[S_EQEQ] = tokenId("equal_equal");

    states[S_BANG]['='] = S_NEQ;
    accepts[S_NEQ] = tokenId("bang_equal");

    accepts[S_LPAREN] = tokenId("lparen");
    accepts[S_RPAREN] = tokenId("rparen");
    accepts[S_LBRACE] = tokenId("lbrace");
    accepts[S_RBRACE] = tokenId("rbrace");
    accepts[S_SEMI] = tokenId("semicolon");
    accepts[S_COMMA] = tokenId("comma");

    // string literal states
    for (&states[S_STRING]) |*v| v.* = S_STRING;
    states[S_STRING]['"'] = S_STRING_END;
    states[S_STRING]['\\'] = S_ESCAPE;

    for (&states[S_ESCAPE]) |*v| v.* = S_STRING;

    accepts[S_STRING_END] = tokenId("string_literal");

    // write file
    try out_file.writeAll("// Auto-generated by lexgen.zig\n");
    try out_file.writeAll("#ifndef DFA_TABLE_H\n#define DFA_TABLE_H\n\n");
    try out_file.writeAll("#include <stdint.h>\n\n");
    var num_buf: [64]u8 = undefined;
    const header = try std.fmt.bufPrint(&num_buf, "#define DFA_INVALID_STATE {d}u\n", .{INVALID_STATE});
    try out_file.writeAll(header);
    try out_file.writeAll("static const uint16_t DFA_STATES[][256] = {\n");
    for (states) |row| {
        try out_file.writeAll("    {");
        for (row, 0..) |val, idx| {
            if (idx != 0) try out_file.writeAll(", ");
            const s = try std.fmt.bufPrint(&num_buf, "{d}", .{val});
            try out_file.writeAll(s);
        }
        try out_file.writeAll("},\n");
    }
    try out_file.writeAll("};\n\n");
    try out_file.writeAll("static const int16_t DFA_ACCEPTS[] = {\n    ");
    for (accepts, 0..) |val, idx| {
        if (idx != 0) try out_file.writeAll(", ");
        const s2 = try std.fmt.bufPrint(&num_buf, "{d}", .{val});
        try out_file.writeAll(s2);
    }
    try out_file.writeAll("\n};\n\n");
    const s3 = try std.fmt.bufPrint(&num_buf, "static const uint16_t DFA_START_STATE = {d};\n", .{START_STATE});
    try out_file.writeAll(s3);
    try out_file.writeAll("\n#endif // DFA_TABLE_H\n");
}

fn tokenId(name: []const u8) i16 {
    if (std.mem.eql(u8, name, "identifier")) return 1;
    if (std.mem.eql(u8, name, "int_literal")) return 2;
    if (std.mem.eql(u8, name, "string_literal")) return 3;
    if (std.mem.eql(u8, name, "plus")) return 8;
    if (std.mem.eql(u8, name, "minus")) return 9;
    if (std.mem.eql(u8, name, "star")) return 10;
    if (std.mem.eql(u8, name, "slash")) return 11;
    if (std.mem.eql(u8, name, "equal")) return 12;
    if (std.mem.eql(u8, name, "equal_equal")) return 13;
    if (std.mem.eql(u8, name, "bang_equal")) return 14;
    if (std.mem.eql(u8, name, "lparen")) return 15;
    if (std.mem.eql(u8, name, "rparen")) return 16;
    if (std.mem.eql(u8, name, "lbrace")) return 17;
    if (std.mem.eql(u8, name, "rbrace")) return 18;
    if (std.mem.eql(u8, name, "semicolon")) return 19;
    if (std.mem.eql(u8, name, "comma")) return 20;
    return -1;
}
